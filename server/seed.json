{
  "users": [
    {
      "_id": { "$oid": "6179ddb959261eb8c736c58d" },
      "registered_at": { "$date": "2021-10-27T23:16:09.717Z" },
      "username": "madeline.mayer",
      "firstname": "Madeline",
      "lastname": "Mayer",
      "avatar": "https://randomuser.me/api/portraits/women/21.jpg",
      "password_hash": "$2b$10$gF.v55lcMIrqNf.arzXboOvvT/xDBFa898UCk0VxwBPrED8ggc2zO",
      "__v": 0
    }
  ],
  "articles": [
    {
      "_id": { "$oid": "6179dee782ec53cf04018f40" },
      "createdAt": { "$date": "2021-10-27T23:21:11.94Z" },
      "title": "Interactive components: less wiring, more inspiring",
      "snippet": "Design isn’t just about how something looks. It’s equally important to nail down how it feels and works. This process can be time-consuming and expensive without a way to quickly experiment and align on solutions. Fortunately, we have prototyping—a low-risk, high-reward way to try out interactive ideas during the design process....",
      "markdown": "Design isn’t just about how something looks. It’s equally important to nail down how it feels and works. This process can be time-consuming and expensive without a way to quickly experiment and align on solutions. Fortunately, we have prototyping—a low-risk, high-reward way to try out interactive ideas during the design process.\r\n\r\nBut compared to visual design, it’s still hard to explore and iterate on interactivity. Because you have to switch tools or manually wire up a prototype, you might skip this step altogether, resulting in extra development time or missed goals.\r\n\r\nToday in Figma, we’re launching interactive components and a handful of smaller improvements to make it easier for teams to create, edit, and share interactive ideas, closing the gap between visual and interactive design workflows.\r\n\r\n## Bring your designs to life with interactive components\r\nWe are thrilled to announce that interactive components are now out of beta and available for everyone to use.\r\n\r\n![Interactive components](https://cdn.sanity.io/images/599r6htc/production/5f7cfe6aea93df5478e6cd1295b56d34b5b8cdb6-2120x1000.png?w=1060&q=75&fit=max&auto=format&dpr=1.5)\r\n\r\nInteractive components allow you to define interactions and animations between variants in a component set, so instances are immediately “alive” in prototyping mode. Having reusable interactive elements cuts down on time spent prototyping, and helps you reach higher levels of fidelity for better feedback and testing. With interactive components, you can:\r\n\r\n### Reduce prototype complexity\r\n\r\nWhat used to require many frames now takes one, making prototypes easier to build and edit. For example, you can select multiple checkboxes or open an accordion menu without additional frames.\r\n\r\n> “[Interactive components] have been a game changer for prototyping, as they allow for minimizing the number of frames while building all UI states and interactions. On some projects, the number of frames has dropped by 10x or more.”\r\n — Denis Vacher, Amazon Web Services (AWS)\r\n\r\n### Speed up prototype creation\r\n\r\nTo allow you to stay in the flow when you’re creating a prototype, you can edit all states of an interactive component directly next to where it’s used. And if you want to try out a different version, just duplicate to iterate.\r\n\r\nWe have come a long way since beta launch, due in large part to our community’s participation and feedback. We are blown away by the incredible examples people have created during the beta ([animated robots](https://www.figma.com/community/file/949783169360682107), a [music notation prototype](https://www.figma.com/community/file/966600174838115017), or just good old [bubble wrap](https://www.figma.com/community/file/948109912804691950)) and love to see that the feature is not only impacting day-to-day workflows, but encouraging teams to think outside the box.\r\n ",
      "author": { "$oid": "6179ddb959261eb8c736c58d" },
      "slug": "interactive-components-less-wiring-more-inspiring",
      "sanitizedHtml": "<p>Design isn’t just about how something looks. It’s equally important to nail down how it feels and works. This process can be time-consuming and expensive without a way to quickly experiment and align on solutions. Fortunately, we have prototyping—a low-risk, high-reward way to try out interactive ideas during the design process.</p>\n<p>But compared to visual design, it’s still hard to explore and iterate on interactivity. Because you have to switch tools or manually wire up a prototype, you might skip this step altogether, resulting in extra development time or missed goals.</p>\n<p>Today in Figma, we’re launching interactive components and a handful of smaller improvements to make it easier for teams to create, edit, and share interactive ideas, closing the gap between visual and interactive design workflows.</p>\n<h2 id=\"bring-your-designs-to-life-with-interactive-components\">Bring your designs to life with interactive components</h2>\n<p>We are thrilled to announce that interactive components are now out of beta and available for everyone to use.</p>\n<p><img alt=\"Interactive components\" src=\"https://cdn.sanity.io/images/599r6htc/production/5f7cfe6aea93df5478e6cd1295b56d34b5b8cdb6-2120x1000.png?w=1060&amp;q=75&amp;fit=max&amp;auto=format&amp;dpr=1.5\"></p>\n<p>Interactive components allow you to define interactions and animations between variants in a component set, so instances are immediately “alive” in prototyping mode. Having reusable interactive elements cuts down on time spent prototyping, and helps you reach higher levels of fidelity for better feedback and testing. With interactive components, you can:</p>\n<h3 id=\"reduce-prototype-complexity\">Reduce prototype complexity</h3>\n<p>What used to require many frames now takes one, making prototypes easier to build and edit. For example, you can select multiple checkboxes or open an accordion menu without additional frames.</p>\n<blockquote>\n<p>“[Interactive components] have been a game changer for prototyping, as they allow for minimizing the number of frames while building all UI states and interactions. On some projects, the number of frames has dropped by 10x or more.”\n — Denis Vacher, Amazon Web Services (AWS)</p>\n</blockquote>\n<h3 id=\"speed-up-prototype-creation\">Speed up prototype creation</h3>\n<p>To allow you to stay in the flow when you’re creating a prototype, you can edit all states of an interactive component directly next to where it’s used. And if you want to try out a different version, just duplicate to iterate.</p>\n<p>We have come a long way since beta launch, due in large part to our community’s participation and feedback. We are blown away by the incredible examples people have created during the beta (<a href=\"https://www.figma.com/community/file/949783169360682107\">animated robots</a>, a <a href=\"https://www.figma.com/community/file/966600174838115017\">music notation prototype</a>, or just good old <a href=\"https://www.figma.com/community/file/948109912804691950\">bubble wrap</a>) and love to see that the feature is not only impacting day-to-day workflows, but encouraging teams to think outside the box.\n </p>\n",
      "__v": 0
    },
    {
      "_id": { "$oid": "6179e2a8a660ff0c4237207e" },
      "createdAt": { "$date": "2021-10-27T23:37:12.975Z" },
      "title": "How Unit Testing is Useful for Engineers",
      "snippet": "An article on the benefits of unit testing for engineers.",
      "markdown": "![enter image description here](https://miro.medium.com/max/2000/1*q5s4ZIM-hlheM6sTM2eDdQ.jpeg)\r\n\r\nMost of the engineers wonder about writing:\r\n\r\n1.  Clean, structured, and reusable code.\r\n2.  Bug-free code.\r\n3.  Easy to maintain and modify the code.\r\n\r\nEngineers try hard to achieve the above but due to the agile nature of the product development, the above points will be missed. But it can be achieved to provide high-quality code at the production level.\r\n\r\nYes, by writing unit test cases we can achieve quality in the code.\r\n\r\nPuzzled, how writing test cases can make our code to be reused and highly maintainable.\r\n\r\nWe all know writing unit tests can ensure quality in the code. Let’s discuss how the remaining can be achieved through unit testing.\r\n\r\nLet us consider this scenario, Mr Smith a Software Engineer (Fresher) is developing a calculator application.\r\n\r\nInitially, the requirements were:\r\n\r\n1.  Two numbers will be given as input.\r\n2.  Addition, subtraction, multiplication, division operations have to be computed.\r\n\r\nJust by getting the above information, he started to write the following python code.\r\n\r\n```python\r\n#calculator.py  \r\n\r\nclass Calculator:  \r\n    def __init__(self, a, b):  \r\n        self.num1 = a  \r\n        self.num2 = b  \r\n      \r\n    def addition(self):  \r\n        return self.num1 + self.num2  \r\n      \r\n    def subtraction(self):  \r\n        return self.num1 - self.num2  \r\n      \r\n    def multiplication(self):  \r\n        return self.num1 * self.num2  \r\n      \r\n    def division(self):  \r\n        return self.num1 / self.num2\r\n```\r\nHe executed the above file to check the calculator’s functionalities.\r\n\r\nAs it is agile development he got new requirements as follows:\r\n\r\n3. Always absolute value should be returned for subtraction.\r\n\r\n4. In division, the denominator should be smaller than the numerator.\r\n\r\nHe modified the above file as required.\r\n\r\n```python\r\nclass Calculator:  \r\n    def __init__(self, a, b):  \r\n        self.num1 = a  \r\n        self.num2 = b  \r\n  \r\n    def addition(self):  \r\n        return self.num1 + self.num2  \r\n  \r\n    def subtraction(self):  \r\n        return abs(self.num1 - self.num2)  \r\n  \r\n    def multiplication(self):  \r\n        return self.num1 * self.num2  \r\n  \r\n    def division(self):  \r\n        return self.num1 / self.num2 if self.num2 < self.num1 else self.num2/self.num1\r\n```\r\n\r\nBut now, he doesn't want to test addition and multiplication functionalities.\r\n\r\nAnd here, the necessity for unit tests arises.\r\n\r\n```python\r\nimport unittest\r\n\r\n\r\nclass TestCalculator(unittest.TestCase):\r\n    def test_addition(self):\r\n        cal = Calculator(2, 4)\r\n        self.assertEquals(cal.addition(), 6)\r\n\r\n    def test_multiplication(self):\r\n        cal = Calculator(2, 4)\r\n        self.assertEquals(cal.multiplication(), 8)\r\n\r\n    def test_subtraction(self):\r\n        cal = Calculator(2, 4)\r\n        self.assertEquals(cal.subtraction(), 2)\r\n\r\n    def test_division(self):\r\n        cal = Calculator(2, 4)\r\n        self.assertEquals(cal.division(), 2)\r\n\r\n```\r\n\r\nThe above test cases will satisfy our testing requirements.\r\n\r\n1.  Here, each functionality of the calculator can be tested separately.\r\n2.  Whenever any new changes are made to any of the functionalities we don't want to test all the untouched features.\r\n\r\n> Ok How does it answers the above question of code quality?\r\n\r\nYes, it is answered. Every engineer will test his/her code for logical correctness in some way. If he/she prefers unit tests then by default it ensures quality in the code. Because unit tests can be more useful\r\n\r\n1.  Only if the logic is bundled in reusable functions — If addition and subtraction are written in a similar piece of code it will be impossible to check each feature separately.\r\n2.  Once if they understood the requirements correctly and if they try to use unit tests then the code will be written in a highly structured manner.\r\n\r\nEven in the future the requirements can change or new requirements can be included, but it is easy to test those features through this unit testing.\r\n\r\nFrom my experience, the above validations helped me a lot to write clean and reusable code.\r\n\r\nThanks for reading.\r\n\r\n_More content at_ [_plainenglish.io_](http://plainenglish.io/)",
      "author": { "$oid": "6179ddb959261eb8c736c58d" },
      "slug": "how-unit-testing-is-useful-for-engineers",
      "sanitizedHtml": "<p><img alt=\"enter image description here\" src=\"https://miro.medium.com/max/2000/1*q5s4ZIM-hlheM6sTM2eDdQ.jpeg\"></p>\n<p>Most of the engineers wonder about writing:</p>\n<ol>\n<li>Clean, structured, and reusable code.</li>\n<li>Bug-free code.</li>\n<li>Easy to maintain and modify the code.</li>\n</ol>\n<p>Engineers try hard to achieve the above but due to the agile nature of the product development, the above points will be missed. But it can be achieved to provide high-quality code at the production level.</p>\n<p>Yes, by writing unit test cases we can achieve quality in the code.</p>\n<p>Puzzled, how writing test cases can make our code to be reused and highly maintainable.</p>\n<p>We all know writing unit tests can ensure quality in the code. Let’s discuss how the remaining can be achieved through unit testing.</p>\n<p>Let us consider this scenario, Mr Smith a Software Engineer (Fresher) is developing a calculator application.</p>\n<p>Initially, the requirements were:</p>\n<ol>\n<li>Two numbers will be given as input.</li>\n<li>Addition, subtraction, multiplication, division operations have to be computed.</li>\n</ol>\n<p>Just by getting the above information, he started to write the following python code.</p>\n<pre><code class=\"language-python\"><span class=\"hljs-comment\">#calculator.py  </span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Calculator</span>:  \n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, a, b</span>):  \n        self.num1 = a  \n        self.num2 = b  \n      \n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">addition</span>(<span class=\"hljs-params\">self</span>):  \n        <span class=\"hljs-keyword\">return</span> self.num1 + self.num2  \n      \n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">subtraction</span>(<span class=\"hljs-params\">self</span>):  \n        <span class=\"hljs-keyword\">return</span> self.num1 - self.num2  \n      \n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">multiplication</span>(<span class=\"hljs-params\">self</span>):  \n        <span class=\"hljs-keyword\">return</span> self.num1 * self.num2  \n      \n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">division</span>(<span class=\"hljs-params\">self</span>):  \n        <span class=\"hljs-keyword\">return</span> self.num1 / self.num2\n</code></pre>\n<p>He executed the above file to check the calculator’s functionalities.</p>\n<p>As it is agile development he got new requirements as follows:</p>\n<ol start=\"3\">\n<li><p>Always absolute value should be returned for subtraction.</p>\n</li>\n<li><p>In division, the denominator should be smaller than the numerator.</p>\n</li>\n</ol>\n<p>He modified the above file as required.</p>\n<pre><code class=\"language-python\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Calculator</span>:  \n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, a, b</span>):  \n        self.num1 = a  \n        self.num2 = b  \n  \n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">addition</span>(<span class=\"hljs-params\">self</span>):  \n        <span class=\"hljs-keyword\">return</span> self.num1 + self.num2  \n  \n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">subtraction</span>(<span class=\"hljs-params\">self</span>):  \n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">abs</span>(self.num1 - self.num2)  \n  \n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">multiplication</span>(<span class=\"hljs-params\">self</span>):  \n        <span class=\"hljs-keyword\">return</span> self.num1 * self.num2  \n  \n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">division</span>(<span class=\"hljs-params\">self</span>):  \n        <span class=\"hljs-keyword\">return</span> self.num1 / self.num2 <span class=\"hljs-keyword\">if</span> self.num2 &lt; self.num1 <span class=\"hljs-keyword\">else</span> self.num2/self.num1\n</code></pre>\n<p>But now, he doesn't want to test addition and multiplication functionalities.</p>\n<p>And here, the necessity for unit tests arises.</p>\n<pre><code class=\"language-python\">import unittest\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-constructor\">TestCalculator(<span class=\"hljs-params\">unittest</span>.TestCase)</span>:\n    def test<span class=\"hljs-constructor\">_addition(<span class=\"hljs-params\">self</span>)</span>:\n        cal = <span class=\"hljs-constructor\">Calculator(2, 4)</span>\n        self.<span class=\"hljs-keyword\">assert</span><span class=\"hljs-constructor\">Equals(<span class=\"hljs-params\">cal</span>.<span class=\"hljs-params\">addition</span>()</span>, <span class=\"hljs-number\">6</span>)\n\n    def test<span class=\"hljs-constructor\">_multiplication(<span class=\"hljs-params\">self</span>)</span>:\n        cal = <span class=\"hljs-constructor\">Calculator(2, 4)</span>\n        self.<span class=\"hljs-keyword\">assert</span><span class=\"hljs-constructor\">Equals(<span class=\"hljs-params\">cal</span>.<span class=\"hljs-params\">multiplication</span>()</span>, <span class=\"hljs-number\">8</span>)\n\n    def test<span class=\"hljs-constructor\">_subtraction(<span class=\"hljs-params\">self</span>)</span>:\n        cal = <span class=\"hljs-constructor\">Calculator(2, 4)</span>\n        self.<span class=\"hljs-keyword\">assert</span><span class=\"hljs-constructor\">Equals(<span class=\"hljs-params\">cal</span>.<span class=\"hljs-params\">subtraction</span>()</span>, <span class=\"hljs-number\">2</span>)\n\n    def test<span class=\"hljs-constructor\">_division(<span class=\"hljs-params\">self</span>)</span>:\n        cal = <span class=\"hljs-constructor\">Calculator(2, 4)</span>\n        self.<span class=\"hljs-keyword\">assert</span><span class=\"hljs-constructor\">Equals(<span class=\"hljs-params\">cal</span>.<span class=\"hljs-params\">division</span>()</span>, <span class=\"hljs-number\">2</span>)\n</code></pre>\n<p>The above test cases will satisfy our testing requirements.</p>\n<ol>\n<li>Here, each functionality of the calculator can be tested separately.</li>\n<li>Whenever any new changes are made to any of the functionalities we don't want to test all the untouched features.</li>\n</ol>\n<blockquote>\n<p>Ok How does it answers the above question of code quality?</p>\n</blockquote>\n<p>Yes, it is answered. Every engineer will test his/her code for logical correctness in some way. If he/she prefers unit tests then by default it ensures quality in the code. Because unit tests can be more useful</p>\n<ol>\n<li>Only if the logic is bundled in reusable functions — If addition and subtraction are written in a similar piece of code it will be impossible to check each feature separately.</li>\n<li>Once if they understood the requirements correctly and if they try to use unit tests then the code will be written in a highly structured manner.</li>\n</ol>\n<p>Even in the future the requirements can change or new requirements can be included, but it is easy to test those features through this unit testing.</p>\n<p>From my experience, the above validations helped me a lot to write clean and reusable code.</p>\n<p>Thanks for reading.</p>\n<p><em>More content at</em> <a href=\"http://plainenglish.io/\"><em>plainenglish.io</em></a></p>\n",
      "__v": 0
    },
    {
      "_id": { "$oid": "6179eec2fa1cb9ff468a799c" },
      "createdAt": { "$date": "2021-10-28T00:28:50.267Z" },
      "title": "Replace null with ES6 Symbols",
      "snippet": "Symbol is the new null",
      "markdown": "When I was working on my small side-project library, I needed to represent a missing value. In the past, I’d used the nullable approach in simple settings and Option (aka Maybe) when I wanted more control.\r\n\r\nIn this case, neither felt correct so I came up with a different approach I’d like to present.\r\n\r\n# Why Nullable was not enough\r\n\r\nNullable means that when there is a value it is a string, a number, or an object. When there is no value, we use either  `null`  or  `undefined`.\r\n\r\n_Tip:_  if you work with nullable types in TypeScript, make sure you turn on the  [`strictNullChecks`](https://www.typescriptlang.org/tsconfig#strictNullChecks)\r\n\r\nThis is often fine.\r\n\r\nThere are, in general, two cases when it’s not:\r\n\r\n1.  The value  _can_  be  `null`  or  `undefined`. In the end, these are both valid JavaScript primitives and people can use them in many ways.\r\n2.  You want to add some advanced logic. Writing  `x == null`  everywhere gets cumbersome.\r\n\r\nIn my case I was handling an output of a Promise, that can return anything. And I could foresee that both of the ‘missing’ will be eventually returned.\r\n\r\nIn general, the problem 1 and 2 have the same solution: use a library that implements the Option type.\r\n\r\n# Why Option was too much\r\n\r\nOption (sometimes called Maybe) type has two possibilities: either there is no value (  `None`  on  `Nothing`) or there is a value (  `Some`  or  `Just`).\r\n\r\nIn JavaScript/TypeScript this means introducing a new structure that wraps the value. Most commonly an object with a property  `tag`  that defines what possibility it is.\r\n\r\nThis is how you could quickly implement Option in TypeScript:\r\n\r\n```js\r\ntype Option<T> = { tag: 'none' } | { tag: 'some', value: T }\r\n```\r\n\r\nUsually, you would use a library that defines the type and a bunch of useful utils alongside.  [Here is an intro to Option in my favourite fp-ts library](https://dev.to/ryanleecode/practical-guide-to-fp-ts-option-map-flatten-chain-6d5).\r\n\r\nThe library I was building was small, had zero dependencies, and there was no need for using any Option utility. Therefore, bringing in an Option library would be overkill.\r\n\r\n\r\nFor a while I was thinking about inlining the Option, that is coding it from scratch. For my use case that would be just a few lines. It would complicate the logic of the library a bit, though.\r\n\r\nThen, I had a better idea!\r\n\r\n# Symbol as the new null\r\n\r\nComing back to Nullable, the unsolvable problem is that  `null`  (or  `undefined`) is global. It is one value equal to itself. It is the same for everybody.\r\n\r\nIf you return  `null`  and I return  `null`, later, it is not possible to find out where the  `null`  comes from.\r\n\r\nIn other words, there is ever only one instance. To solve it, we need to have a new instance of  `null`.\r\n\r\nSure, we could use an empty object. In JavaScript each object is a new instance that is not equal to any other object.\r\n\r\nBut hey, in ES6 we got a new primitive that does exactly that: Symbol. (Read some  [introduction to Symbols](https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/))\r\n\r\nWhat I did was a new constant that represented a missing value, which was a symbol:\r\n\r\n```js\r\nconst None = Symbol(`None`)\r\n```\r\n\r\nLet’s look at the benefits:\r\n\r\n-   It is a simple value, no wrapper needed\r\n-   Anything else is treated as data\r\n-   It’s a private None, the symbol cannot be recreated elsewhere\r\n-   It has no meaning outside our code\r\n-   The label makes debugging easier\r\n\r\nThat is great! Especially the first point allows using None as  `null`. See some example use:\r\n\r\n```js\r\nconst isNone = (value: unknown) => value === None\r\n\r\nconst hasNone = (arr: Array<unknown>) =>\r\n  arr.some((x) => x === None)\r\n\r\nconst map = <T, S>(\r\n  fn: (x: T) => S,\r\n  value: T | typeof None\r\n) => {\r\n  if (value === None) {\r\n    return None\r\n  } else {\r\n    return fn(value)\r\n  }\r\n}\r\n```\r\n\r\n# Symbols are almost nulls\r\n\r\nThere are some disadvantages, too.\r\n\r\nFirst, which is IMO rare, is that the environment has to  [support ES6 Symbols](https://caniuse.com/mdn-javascript_builtins_symbol). That means Node.js >=0.12 (not to be confused with v12).\r\n\r\nSecond, there are problems with (de)serialisation. Funnily, Symbols behave exactly like  `undefined`.\r\n\r\n```js\r\nJSON.stringify({ x: Symbol(), y: undefined })\r\n// -> \"{}\"\r\n\r\nJSON.stringify([Symbol(), undefined])\r\n// -> \"[null,null]\"\r\n```\r\n\r\nSo, the information about the instance is, of course, lost. Yet, since it then behaves like  `undefined`  -the native 'missing value')-makes it well suited for representing a custom 'missing value'.\r\n\r\nIn contrast, Option is based on structure not instances. Any object with a property  `tag`  set to  `none`  is considered None. This allows for easier serialisation and deserialisation.\r\n\r\n# Summary\r\n\r\nI’m rather happy with this pattern. It seems it’s a safer alternative to  `null`  in places where no advanced operations on the property are needed.\r\n\r\nMaybe, I’d avoid it if this custom symbol should leak outside of a module or a library.\r\n\r\nI especially like that with the variable name and the symbol label, I can communicate the domain meaning of the missing value. In my small library it represents that the promise is not settled:\r\n```js\r\nconst notSettled = Symbol(`not-settled`)\r\n```\r\n\r\nPotentially, there could be multiple missing values for different domain meanings.\r\n\r\n> _Let me know what you think of this use? Is it a good replacement for_ `_null_`_? Should everybody always use an Option?_\r\n\r\nNote: Symbols are not always easy to use, watch my talk  _Symbols complicated it all_.",
      "author": { "$oid": "6179ddb959261eb8c736c58d" },
      "slug": "replace-null-with-es6-symbols",
      "sanitizedHtml": "<p>When I was working on my small side-project library, I needed to represent a missing value. In the past, I’d used the nullable approach in simple settings and Option (aka Maybe) when I wanted more control.</p>\n<p>In this case, neither felt correct so I came up with a different approach I’d like to present.</p>\n<h1 id=\"why-nullable-was-not-enough\">Why Nullable was not enough</h1>\n<p>Nullable means that when there is a value it is a string, a number, or an object. When there is no value, we use either  <code>null</code>  or  <code>undefined</code>.</p>\n<p><em>Tip:</em>  if you work with nullable types in TypeScript, make sure you turn on the  <a href=\"https://www.typescriptlang.org/tsconfig#strictNullChecks\"><code>strictNullChecks</code></a></p>\n<p>This is often fine.</p>\n<p>There are, in general, two cases when it’s not:</p>\n<ol>\n<li>The value  <em>can</em>  be  <code>null</code>  or  <code>undefined</code>. In the end, these are both valid JavaScript primitives and people can use them in many ways.</li>\n<li>You want to add some advanced logic. Writing  <code>x == null</code>  everywhere gets cumbersome.</li>\n</ol>\n<p>In my case I was handling an output of a Promise, that can return anything. And I could foresee that both of the ‘missing’ will be eventually returned.</p>\n<p>In general, the problem 1 and 2 have the same solution: use a library that implements the Option type.</p>\n<h1 id=\"why-option-was-too-much\">Why Option was too much</h1>\n<p>Option (sometimes called Maybe) type has two possibilities: either there is no value (  <code>None</code>  on  <code>Nothing</code>) or there is a value (  <code>Some</code>  or  <code>Just</code>).</p>\n<p>In JavaScript/TypeScript this means introducing a new structure that wraps the value. Most commonly an object with a property  <code>tag</code>  that defines what possibility it is.</p>\n<p>This is how you could quickly implement Option in TypeScript:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-built_in\">type</span> Option<span class=\"hljs-symbol\">&lt;T&gt;</span> = { <span class=\"hljs-keyword\">tag</span>: <span class=\"hljs-string\">'none'</span> } | { <span class=\"hljs-keyword\">tag</span>: <span class=\"hljs-string\">'some'</span>, value: T }\n</code></pre>\n<p>Usually, you would use a library that defines the type and a bunch of useful utils alongside.  <a href=\"https://dev.to/ryanleecode/practical-guide-to-fp-ts-option-map-flatten-chain-6d5\">Here is an intro to Option in my favourite fp-ts library</a>.</p>\n<p>The library I was building was small, had zero dependencies, and there was no need for using any Option utility. Therefore, bringing in an Option library would be overkill.</p>\n<p>For a while I was thinking about inlining the Option, that is coding it from scratch. For my use case that would be just a few lines. It would complicate the logic of the library a bit, though.</p>\n<p>Then, I had a better idea!</p>\n<h1 id=\"symbol-as-the-new-null\">Symbol as the new null</h1>\n<p>Coming back to Nullable, the unsolvable problem is that  <code>null</code>  (or  <code>undefined</code>) is global. It is one value equal to itself. It is the same for everybody.</p>\n<p>If you return  <code>null</code>  and I return  <code>null</code>, later, it is not possible to find out where the  <code>null</code>  comes from.</p>\n<p>In other words, there is ever only one instance. To solve it, we need to have a new instance of  <code>null</code>.</p>\n<p>Sure, we could use an empty object. In JavaScript each object is a new instance that is not equal to any other object.</p>\n<p>But hey, in ES6 we got a new primitive that does exactly that: Symbol. (Read some  <a href=\"https://hacks.mozilla.org/2015/06/es6-in-depth-symbols/\">introduction to Symbols</a>)</p>\n<p>What I did was a new constant that represented a missing value, which was a symbol:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title class_\">None</span> = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">`None`</span>)\n</code></pre>\n<p>Let’s look at the benefits:</p>\n<ul>\n<li>It is a simple value, no wrapper needed</li>\n<li>Anything else is treated as data</li>\n<li>It’s a private None, the symbol cannot be recreated elsewhere</li>\n<li>It has no meaning outside our code</li>\n<li>The label makes debugging easier</li>\n</ul>\n<p>That is great! Especially the first point allows using None as  <code>null</code>. See some example use:</p>\n<pre><code class=\"language-js\">const isNone = <span class=\"hljs-function\"><span class=\"hljs-params\">(value: unknown)</span> =&gt;</span> value === None\n\nconst hasNone = <span class=\"hljs-function\"><span class=\"hljs-params\">(arr: <span class=\"hljs-built_in\">Array</span>&lt;unknown&gt;)</span> =&gt;</span>\n  arr.some(<span class=\"hljs-function\"><span class=\"hljs-params\">(x)</span> =&gt;</span> x === None)\n\nconst map = &lt;T, S&gt;(\n  fn: <span class=\"hljs-function\"><span class=\"hljs-params\">(x: T)</span> =&gt;</span> S,\n  value: T | <span class=\"hljs-keyword\">typeof</span> None\n) =&gt; {\n  <span class=\"hljs-keyword\">if</span> (value === None) {\n    <span class=\"hljs-keyword\">return</span> None\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-keyword\">return</span> fn(value)\n  }\n}\n</code></pre>\n<h1 id=\"symbols-are-almost-nulls\">Symbols are almost nulls</h1>\n<p>There are some disadvantages, too.</p>\n<p>First, which is IMO rare, is that the environment has to  <a href=\"https://caniuse.com/mdn-javascript_builtins_symbol\">support ES6 Symbols</a>. That means Node.js &gt;=0.12 (not to be confused with v12).</p>\n<p>Second, there are problems with (de)serialisation. Funnily, Symbols behave exactly like  <code>undefined</code>.</p>\n<pre><code class=\"language-js\"><span class=\"hljs-built_in\">JSON</span>.stringify({ x: <span class=\"hljs-built_in\">Symbol</span>(), y: <span class=\"hljs-literal\">undefined</span> })\n<span class=\"hljs-regexp\">//</span> -&gt; <span class=\"hljs-string\">\"{}\"</span>\n\n<span class=\"hljs-built_in\">JSON</span>.stringify([<span class=\"hljs-built_in\">Symbol</span>(), <span class=\"hljs-literal\">undefined</span>])\n<span class=\"hljs-regexp\">//</span> -&gt; <span class=\"hljs-string\">\"[null,null]\"</span>\n</code></pre>\n<p>So, the information about the instance is, of course, lost. Yet, since it then behaves like  <code>undefined</code>  -the native 'missing value')-makes it well suited for representing a custom 'missing value'.</p>\n<p>In contrast, Option is based on structure not instances. Any object with a property  <code>tag</code>  set to  <code>none</code>  is considered None. This allows for easier serialisation and deserialisation.</p>\n<h1 id=\"summary\">Summary</h1>\n<p>I’m rather happy with this pattern. It seems it’s a safer alternative to  <code>null</code>  in places where no advanced operations on the property are needed.</p>\n<p>Maybe, I’d avoid it if this custom symbol should leak outside of a module or a library.</p>\n<p>I especially like that with the variable name and the symbol label, I can communicate the domain meaning of the missing value. In my small library it represents that the promise is not settled:</p>\n<pre><code class=\"language-js\"><span class=\"hljs-keyword\">const</span> notSettled = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">`not-settled`</span>)\n</code></pre>\n<p>Potentially, there could be multiple missing values for different domain meanings.</p>\n<blockquote>\n<p><em>Let me know what you think of this use? Is it a good replacement for</em> <code>_null_</code><em>? Should everybody always use an Option?</em></p>\n</blockquote>\n<p>Note: Symbols are not always easy to use, watch my talk  <em>Symbols complicated it all</em>.</p>\n",
      "__v": 0
    }
  ]
}
